[{"url":".","title":"index","tags":["homepage"],"text":""},{"url":"installation/","title":"Software installation","tags":["welcome"],"text":"Step 1: Install Julia Download the current stable release of Julia on  https://julialang.org/downloads , using the correct version for your operating system (Linux x86, Mac, Windows, etc). Step 2: Install RadiiPolynomial Next we will install  RadiiPolynomial , the library for computer-assisted proofs that we will be using during the course. RadiiPolynomial is a Julia package designed for computer-assisted proofs relying on spectral methods and the contraction mapping theorem. Open the  Julia REPL . This is the command-line interface to Julia: there you type a command, and when you press ENTER, it runs, and you see the result. To install RadiiPolynomial, we want to run a  package manager command . To switch from  Julia mode  to  Pkg mode , type  ]  (closing square bracket) at the  julia>  prompt: \n julia>  ]\n\n (@v 1.10 ) pkg> \n The line turns blue and the prompt changes to  pkg> , telling you that you are now in  package manager mode . This mode allows you to do operations on  packages  (also called libraries). Run the following (case sensitive) command to  add  (install) the package to your system by downloading it from the internet (you should only need to do this  once  for each installation of Julia): \n (@v 1.10 ) pkg>  add RadiiPolynomial\n \n Step 3: Running RadiiPolynomial To use the RadiiPolynomial library, type the following command in the REPL: \n julia>  using RadiiPolynomial\n \n \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst sortby = v => v.split(\"-\")[0].split(\".\").map(parseFloat).reduce((a,b) => a*10000 + b)\nconst version_names = Object.keys(versions).sort((a,b) => sortby(a) - sortby(b)).reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"logistics/","title":"Class logistics","tags":["welcome"],"text":"Have fun!"},{"url":"assets/scripts/get_highlights/","title":"get_highlights","tags":[],"text":"if isempty get metadata \"homepage\" , \"highlights\", nothing else highlights htl \"\"\" section div class \"content\" h2 x \"name\" h2 p x \"text\" p div div class \"preview\" img src \" x \"img\" \" div section \"\"\" for x in metadata \"homepage\" \"highlights\" htl \"\"\" div class \"subjectscontainer wide\" h1 Highlights h1 div class \"contain\" highlights div div \"\"\" end "},{"url":"assets/scripts/get_subjects/","title":"get_subjects","tags":[],"text":"let sections metadata \"sidebar\" sections htl \"\"\" let input other page.input output other page.output name get output.frontmatter, \"title\", basename input.relative path desc get output.frontmatter, \"description\", nothing tags get output.frontmatter, \"tags\", String image get output.frontmatter, \"image\", nothing class \"no decoration\", \"tag replace x, \" \" \" \" \" for x in tags ..., image nothing || isempty image ? nothing htl \"\"\" a title desc class class href root url \" \" other page.url h3 name h3 img src image a \"\"\" image nothing || isempty image ? nothing htl \"\"\" a title desc class class href root url \" \" other page.url h3 name h3 a \"\"\" end for other page in collections section id .pages \"\"\" for section id, section name in sections isempty sections ? nothing htl \"\"\" div class \"wide subjectscontainer\" div class \"subjects\" sections div div \"\"\" end "},{"url":"homework/hw1/","title":"Periodic orbits","tags":["module2","homeworks"],"text":" A Pluto.jl notebook v0.19.25 frontmatter homework number \"1\" order \"3.5\" title \"Periodic orbits\" tags \"module2\", \"homeworks\" layout \"layout.jlhtml\" description \"Periodic orbits\" using Markdown using InteractiveUtils using PlutoTeachingTools, PlutoUI md\"\"\" Sample Homework This notebook showcases some of the features of `PlutoTeachingTools.jl` https github.com JuliaPluto PlutoTeachingTools.jl and how to use these to write homework assignment in Pluto. \"\"\" tip md\"\"\"For a deeper tour of `PlutoTeachingTools.jl`, check their documentation https juliapluto.github.io PlutoTeachingTools.jl example.html \"\"\" md\"\"\" Useful functionalities `PlutoTeachingTools.jl` has some functions like `correct`, `still missing`, here a few demoes \"\"\" correct still missing keep working keep working md\"you can also give custom text to the boxes\" hint md\"this is a hint, hover the box to unblur the text\" md\"\"\" Exercise 1 a simple exercise Replace missing with the value `1`. \"\"\" x missing if ismissing x still missing elseif x 1 && x isa Int correct elseif x 1 && x isa Int b1 almost md\"\"\"Your variable has the right value, but it's not quite the right answer. Read carefully the instructions\"\"\" b2 hint md\"\"\"What type should the value of x be?\"\"\" md\"\"\" b1 b2 \"\"\" else keep working md\"\"\"That is not the right answer Keep trying \"\"\" end md\"\"\" here is a short demo of how it looks like when the student tries to solve the exercise \"\"\" Resource \"https user images.githubusercontent.com 49938764 249749643 8cc12de3 2b50 4182 b95d 686c2c18332c.mov\", width 500, autoplay \"\", loop \"\" md\"\"\" Exercise 2 Write a function called `myfun` that takes as input an integer and returns its square. Define a variable called `y` and assign `myfun 3 ` to it. \"\"\" let if isdefined myfun func not defined myfun else test values 1, 2, 3, 4, 5 msg1 correct for t in test values if myfun t t^2 msg1 keep working md\"Test failed for input t, expected t^2 , but got myfun t \" break end end msg1 end end if isdefined y var not defined y elseif y 9 correct else keep working md\"Evaluated expression y y is incorrect.\" end md\"\"\" and here is a quick demo of the exercise in action \"\"\" Resource \"https user images.githubusercontent.com 49938764 249748007 d0b2d773 6b21 49d4 89db ad737af510fe.mov\", width 500, autoplay \"\", loop \"\" "},{"url":"homework/mod1_hw1/","title":"Operator norms","tags":["module1","homeworks"],"text":" A Pluto.jl notebook v0.19.45 frontmatter homework number \"1\" order \"1.5\" title \"Operator norms\" tags \"module1\", \"homeworks\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils using PlutoUI, Plots, RadiiPolynomial, PlutoTeachingTools md\"\"\" 1. Consider the 1 norm on \\mathbb R ^d \\Vert x\\Vert 1 \\sum i 1 ^d \\vert x i\\vert , and let A be a d\\times d matrix of real numbers. Show that the operator norm induced by the 1 norm can be expressed as \\begin align \\left\\Vert A\\right\\Vert 1 \\max 1\\leq j\\leq d \\sum i 1 ^d \\vert A i,j \\vert. \\end align \"\"\" md\"\"\" 2. Let us generalize this result to infinite dimensional spaces this will be useful for later parts of the tutorial . Consider a sequences of positive weights \\omega k , k\\in\\mathbb N , and the sequence space \\begin align \\ell^1 \\omega \\left\\ x \\in \\mathbb R ^ \\mathbb N ,\\ \\Vert x\\Vert \\omega \\sum i\\in\\mathbb N \\vert x i\\vert \\omega i \\infty \\right\\ . \\end align Given an infinite matrix A \\left A i,j \\right i,j\\in\\mathbb N representing a linear operator on \\ell^1 \\omega , derive a formula for the operator norm of A . \"\"\" "},{"url":"homework/mod1_hw2/","title":"Back to period 3 implies chaos","tags":["module1","homeworks"],"text":" A Pluto.jl notebook v0.19.45 frontmatter homework number \"2\" order \"1.5\" title \"Back to period 3 implies chaos\" tags \"module1\", \"homeworks\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils using PlutoUI, Plots, RadiiPolynomial, PlutoTeachingTools md\"\"\" In order to study period 3 orbits in the dynamical system x n 1 \\mu x n 1 x n , we consider the map \\begin align F \\ \\left\\ \\begin aligned \\mathbb R ^3 &\\to \\mathbb R ^3 \\\\ \\begin pmatrix x 0 \\\\ x 1 \\\\ x 2 \\end pmatrix &\\mapsto \\begin pmatrix \\mu x 0 1 x 0 x 1 \\\\ \\mu x 1 1 x 1 x 2 \\\\ \\mu x 2 1 x 2 x 0 \\end pmatrix \\end aligned \\right. \\end align \"\"\" md\"\"\" 1. Using the implementation of F and DF provided in the following cells, and the Newton method function from RadiiPolynomial.jl, find an approximate period 3 orbit \\bar x , for \\mu 3.9 . \"\"\" We should give them proper implementation of F and DF here. function F x, μ x₀, x₁, x₂ x return Sequence μ x₀ 1 x₀ x₁, μ x₁ 1 x₁ x₂, μ x₂ 1 x₂ x₀ end function DF x, μ x₀, x₁, x₂ x return LinearOperator μ 1 2x₀ 1 0 0 μ 1 2x₁ 1 1 0 μ 1 2x₂ end μ 3.9 newton x F x, μ , DF x, μ , Sequence 1.0, 2.0, 3.0 md\"\"\" 2. Define a suitable A to be used later in the Newton Kantorovich argument. \"\"\" md\"\"\" 3. Using the 1 norm on \\mathbb R ^3 , show that the constant function Z 2 r 2\\mu \\left\\Vert A\\right\\Vert 1 satisfies the assumption of the Newton Kantorovich theorem. \"\"\" hint md\"You may first compute D^2F \\bar x u,v and show that \\Vert D^2F \\bar x u,v \\Vert 1 \\leq 2\\mu \\Vert u\\Vert 1 \\Vert v\\Vert 1 .\" md\"\"\" 4. Implement and evaluate suitable bounds Y , Z 1 and Z 2 , and use the function `interval of existence` from RadiiPolynomial.jl in order to prove the existence of a period 3 orbit for \\mu 3.9 . \"\"\" Y ... Z₁ ... R Inf since Z₂ is constant Z₂ ... interval of existence Y, Z₁, Z₂, R "},{"url":"homework/mod1_hw3/","title":"Rigorous computation of an eigenpair","tags":["module1","homeworks"],"text":" A Pluto.jl notebook v0.19.45 frontmatter homework number \"3\" order \"1.5\" title \"Rigorous computation of an eigenpair\" tags \"module1\", \"homeworks\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils using PlutoUI, Plots, RadiiPolynomial, PlutoTeachingTools, LinearAlgebra md\"\"\" 1. Consider a matrix M , and an approximate eigenpair \\bar \\lambda ,\\bar u of M . Assuming the corresponding exact eigenvalue \\lambda is simple, define a suitable F 0 problem, and derive the bounds needed to apply the Newton Kantorovich theorem in that context. \"\"\" hint md\"The natural zero finding problem is G \\lambda,u M \\lambda I u , but it has one too many unknowns. This is consistent with the fact that zeros of G are not isolated one can always rescale the eigenvector . Therefore, a suitable zero finding problem needs to incorporate a normalization condition, for instance \\begin align F \\lambda,u \\begin pmatrix \\langle u,\\bar u \\rangle 1 \\\\ M \\lambda I u \\end pmatrix . \\end align \" md\"\"\" 2. For any positive integer N , the Wilkinson matrix W 2N 1 is the following 2N 1 \\times 2N 1 tridiagonal matrix \\begin align W 2N 1 \\begin pmatrix N & 1 & & & & & \\\\ 1 & N 1 & 1 & & & & \\\\ & 1 & \\ddots & \\ddots & & & \\\\ & & \\ddots & 0 & \\ddots & & \\\\ & & & \\ddots & \\ddots & 1 & \\\\ & & & & 1 & N 1 & 1 \\\\ & & & & & 1 & N \\end pmatrix \\end align Rigorously enclose all eigenpairs of W 7 . \"\"\" We should probably provide them with some code to get numerical eigenpairs, and maybe also some code for W 2N 1 function W N M zeros 2N 1, 2N 1 for i 1 2N 1 M i,i abs N i 1 if i 1 ≤ 2N 1 M i,i 1 1 end if i 1 ≥ 1 M i,i 1 1 end end return M end N 10 W N eigenvalues, eigenvectors eigen W N "},{"url":"homework/mod1_hw4/","title":"Rigorous inverse of a matrix","tags":["module1","homeworks"],"text":" A Pluto.jl notebook v0.19.43 frontmatter homework number \"4\" order \"1.5\" title \"Rigorous inverse of a matrix\" tags \"module1\", \"homeworks\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI, Plots, RadiiPolynomial, PlutoTeachingTools md\"\"\" In this exercise, we consider a matrix M , and a numerically computed approximate inverse \\bar X of M . Our goal will be to guarantee a posteriori that M is indeed invertible, and to provide a computable error bound between M^ 1 and \\bar X , for any submultiplicative matrix norm i.e., such that \\Vert A B\\Vert \\leq \\Vert A\\Vert \\Vert B \\Vert . \"\"\" md\"\"\" 1. Denoting \\delta \\Vert I M\\bar X \\Vert , and assuming \\delta 1 , show that M is invertible and \\begin align \\Vert M^ 1 \\bar X \\Vert \\leq \\frac \\delta 1 \\delta \\Vert B\\Vert. \\end align \"\"\" hint md\"Write \\left M\\bar X \\right ^ 1 as \\left I M\\bar X I\\right ^ 1 , and mutliply to the left by \\bar X in order to get a power series expansion of M^ 1 \" md\"\"\" 2. Try to obtain a similar estimate using an appropriate zero finding problem and the Newton Kantorovich approach. \"\"\" hint md\"You may consider F X MX I or F X XM I .\" "},{"url":"homework/mod1_hw5/","title":"Rigorous control of the entire spectrum","tags":["module1","homeworks"],"text":" A Pluto.jl notebook v0.19.43 frontmatter homework number \"5\" order \"1.5\" title \"Rigorous control of the entire spectrum\" tags \"module1\", \"homeworks\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoUI, Plots, RadiiPolynomial, PlutoTeachingTools md\"\"\" Exercise C can be used to enclose eigenvalues of a given matrix one by one. We now present an alternate strategy to enclose the entire spectrum at once but not the corresponding eigenvectors , which can sometimes also be adapted in infinite dimension. \"\"\" md\"\"\" We recall the Gershgorin circle theorem for any matrix A \\left A i,j \\right 1\\leq i,j\\leq d , \\begin align \\mathrm Sp A \\subset \\bigcup i 1 ^d D\\left A i,i ,\\, \\sum j\\neq i \\vert A i,j \\vert\\right , \\end align where D z,r denotes the closed disk of center z in radius r in the complex plane. Moreover, if I \\subset \\ 1,\\ldots,d\\ is such that \\begin align \\bigcup i\\in I D\\left A i,i ,\\, \\sum j\\neq i \\vert A i,j \\vert\\right \\quad \\text is disjoint from \\quad \\bigcup i\\notin I D\\left A i,i ,\\, \\sum j\\neq i \\vert A i,j \\vert\\right , \\end align then \\begin align \\bigcup i\\in I D\\left A i,i ,\\, \\sum j\\neq i \\vert A i,j \\vert\\right \\quad \\text contains exactly \\vert I\\vert \\text eigenvalues. \\end align \"\"\" md\"\"\" 1. Using the Gershgorin circle theorem, get as tight as possible rigorous enclosures of all eigenvalues of W 7 defined in exercise C . \"\"\" hint md\"You may first compute numerically a matrix P of approximate eigenvectors of W 7 , then rigorously compute \\tilde W 7 P^ 1 W 7 P , and finally apply the Gershgoring circle theorem to \\tilde W 7 .\" md\"\"\" 2. Try to prove that W 1001 has exactly one eigenvalue with positive real part. \"\"\" hint md\"You do not need to numerically diagonalize all of W 1001 for most rows, the corresponding Gershgorin disk already lies in the left half of the complex plane. \" md\"\"\" Rigorous continuation \"\"\" md\"\"\" Try to prove that there exists a period 3 orbit in x n 1 \\mu x n 1 x n , for all \\mu in an interval containing 3.9 , and make that interval as large as you can. \"\"\" "},{"url":"mod1/finite_dimensions/","title":"Finite Dimensions","tags":["module1"],"text":" A Pluto.jl notebook v0.19.45 frontmatter chapter 1 order \"1\" title \"Finite Dimensions\" tags \"module1\" layout \"layout.jlhtml\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end using PlutoTeachingTools, PlutoUI, RadiiPolynomial, Plots html\"\"\" style main max width 1000px margin left auto margin right auto text align justify \"\"\" md\"\"\" Motivating example a chaotic dynamical system Consider the sequence defined by ```math \\begin equation \\tag 1.1 \\label eq logistic x n 1 \\mu x n 1 x n , \\end equation ``` where \\mu is a parameter in 0,4 and the initial condition x 0 is in 0,1 . \"\"\" md\"\"\" The slider below can be used to vary the value of \\mu . Equation \\eqref eq logistic \"\"\" bind mu Slider 0 0.1 4 default 3.9 mu begin x0 0.4 nb it 50 x zeros nb it 1 x 1 x0 for n 1 nb it x n 1 mu x n 1 x n end plot 0 nb it, x, marker circle,5 , legend false xlabel \"n\" ylims 0.1, 1.1 end Markdown.MD Markdown.Admonition \"tip\", \"Theorem Ref \", md\"Let f 0,1 \\to 0,1 be continuous, and consider the dynamical system defined by x n 1 f x n . If there exist an orbit of period 3, i.e. x 0 in 0,1 such that x 0\\neq x 1\\neq x 2 and x 3 x 0 , then the system is chaotic . In particular, there exists orbits of any period.\" md\"\"\" Let us fix a value of \\mu for which the dynamics seems complicated, say \\mu 3.9 . Our goal will be to prove the existence of a period 3 orbit, by first finding numerically an approximate period 3 orbit, and then proving a posteriori the existence of a true period 3 orbit nearby. There are several ways to prove the existence of a period 3 orbit for this example with and without computer assistance , but the ideas we are going to present and use will generalize to more complicated, infinite dimensional, problems. \"\"\" md\"\"\" Contraction mapping and Newton Kantorovich theorem \"\"\" md\"\"\" Given a problem and an approximate solution \\bar x , we would like to find a fixed point operator T such that Solutions to our problem are in one to one correspondence with fixed points of T , T is a contraction on a small neighborhood of \\bar x . How to define such a T may of course depend on the problem at hand, but we will give below a generic strategy. First, we give sufficient conditions, that we can explicitly try to check in practice, allowing to prove that an operator T is contracting on a small neighborhood of \\bar x . Even though we only deal with finite dimentional problems in this first part of the tutorial, we already state these conditions in a general Banach space, as they will also be heavily used in the remainder of the tutorial. \"\"\" Markdown.MD Markdown.Admonition \"tip\", \"Theorem\", md\"\"\" Let X be a Banach space, \\bar x \\in X , and T X\\to X a continously differentiable map. Assume there exists a constant Y and a non decreasing map Z 0,\\infty \\to 0,\\infty such that \\begin align \\Vert T \\bar x \\bar x \\Vert &\\leq Y \\\\ \\Vert DT x \\Vert &\\leq Z \\Vert x \\bar x \\Vert \\quad \\forall~x\\in X. \\end align It there exists r 0 such that \\begin align Y \\int 0^r Z s \\mathrm d s &\\leq r \\\\ Z r & 1, \\end align then T has a unique fixed point x^ such that \\Vert x^ \\bar x \\Vert \\leq r . \"\"\" Markdown.MD Markdown.Admonition \"note\", \"Remarks\", md\"\"\" The bound Z is actually only needed locally, i.e. we only need Z s for s\\leq r . Therefore, one can fix a priori some r^ 0 , and only ask for Z to be defined on 0,r^ and to satisfy \\Vert DT x \\Vert \\leq Z \\Vert x \\bar x \\Vert for all x in X such that \\Vert x \\bar x \\Vert \\leq r^ . Of course, we are then only allowed to consider r\\in 0,r^ . In practice, studying carefully how \\Vert DT x depends on \\Vert x \\bar x \\Vert allows us to get better bounds. However, we can sometimes get away with crude estimates. That is, we derive a constant Z^ such that \\Vert DT x \\Vert \\leq Z^ for all x in X such that \\Vert x \\bar x \\Vert \\leq r^ , and then use Z s Z^ for all s\\leq r^ . The conditions on r then simplify, and, if Z^ 1 , we can take any r\\geq \\frac Y 1 Z^ . \"\"\" md\"\"\" Going back to a dynamical system x n 1 f x n , a natural fixed point operator for period 3 orbits is given by T x f^3 x , i.e. f composed with itself three times. However, such a T has no reason to be contracting near a period 3 orbit. In order to get a general procedure to construct a fixed point problem, one can start by finding a map F such that solutions of our problem are isolated zeros of F . Then, given an approximate solution \\bar x , one can consider the Newton like fixed point operator T x x DF \\bar x ^ 1 F x , which should be contracting on a neighborhood of \\bar x , as DT \\bar x 0 . For finite dimensional problems of moderate size , the inverse of DF \\bar x is mostly innocous, but DF \\bar x ^ 1 may become very hard to deal with for infinite dimensional problems. Therefore, one often considers instead an approximate inverse A\\approx DF \\bar x ^ 1 and the fixed point operator T x x AF x . We state all following results in this context, for an A which is not specified and could actually but does not have to be DF \\bar x ^ 1 . \"\"\" Markdown.MD Markdown.Admonition \"tip\", \"Corollary\", md\"\"\" Let X and Y be two Banach spaces, \\bar x \\in X , F X\\to Y a continously differentiable map, A Y\\to X an injective linear map, and r^ 0 . Assume there exists constants Y and Z 1 and a non decreasing map Z 2 0,r^ \\to 0,\\infty such that \\begin align \\Vert AF \\bar x \\Vert &\\leq Y \\\\ \\Vert I ADF \\bar x \\Vert &\\leq Z 1 \\\\ \\Vert A DF x DF \\bar x \\Vert &\\leq Z 2 \\Vert x \\bar x \\Vert \\quad \\forall~x\\in X \\text such that \\Vert x \\bar x \\Vert \\leq r^ . \\end align It there exists r 0 such that \\begin align Y Z 1 r \\frac 1 2 Z 2 r^2 &\\leq r \\\\ Z 1 Z 2 r & 1, \\end align then F has a unique zero x^ such that \\Vert x^ \\bar x \\Vert \\leq r . \"\"\" md\"\"\" This corollary is a simplified version of the Newton Kantorovich Theorem Ref . Many slight variations can be found in the literature, and are used in many many CAPs ^1 . \"\"\" md\"\"\" Interval arithmetic \"\"\" md\"\"\" When we want to use the Newton Kantorovich theorem with \\bar x being an approximate solution obtained using the computer, we also need to use the computer to evaluate quantities like \\Vert F \\bar x \\Vert and get the required bounds Y and Z . However, by default the computer will evaluate \\Vert F \\bar x \\Vert using floating point arithmetic, and the output will contain rounding errors. In particular, if we set Y \\Vert F \\bar x \\Vert on the compputer, we in fact do not know whether Y actually satifies the assumption of the Newton Kantorovich theorem or not. Interval arithmetic gives us a way to control rounding errors and to get guaranteed results from the computer. We only give a brief description of interval arithmetic here, and refer to Refs for more comprehensive treatments. \"\"\" md\"\"\" When a command like `a 0.1` is executed, the computer associates to the variable `a` a single floating point number the floating point number which is the closest to the real number 0.1 . However, because 0.1 does not have a finite representation in base 2, 0.1 is not a floating point number, so the value stored in `a` is already not equal to 0.1 . It turns out to be slightly larger than 0.1 , but it could very well have been the other way around. \"\"\" a 0.1 a 1 10 md\"\"\" When using interval arithmetic, we can instead represent any real number by an interval, whose end points are floating point numbers. That is, the computer can also represent `a` as an interval \\underline a ,\\overline a , whose end points should be floating point numbers satisfying \\underline a \\leq a \\leq \\overline a . We give up the hope of representing numbers exactly, but we recover guaranteed information the real number a is contained in the interval representing it on the computer. \"\"\" ia I\"0.1\" interval 1 interval 10 in interval 1 10,ia md\"\"\" The rules of interval arithmetic then ensure that this property is preserved when doing arithmetic operations. For instance, consider two intervals `a` and `b` of the form \\underline a ,\\overline a and \\underline b ,\\overline b , containing the reals numbers a and b . When we do `c a b`, the resulting interval \\underline c ,\\overline c for `c` is computed as follows. For \\underline c , we take \\underline a \\underline b rounded downward a sum of two floating points numbers is not necessarily a floating point number , and for \\overline c we take \\overline a \\overline b rounded upward . In particular, the real number c a b is contained in the interval `c`. \"\"\" md\"\"\" Similarly, if the variable `c` is an interval \\underline c ,\\overline c , and we do `d exp c `, we would like to get for `d` an interval containing \\ \\exp c ,\\ d\\in \\underline d ,\\overline d \\ . Usual arithmetic operations, as well as implementations of basic functions like `exp`, `log`, etc, complying with these rules are provided in interval arithmetic libraries. Refs \"\"\" c interval 2,4 d cos exp sqrt c Markdown.MD Markdown.Admonition \"note\", \"Remarks\", md\"\"\" Remark. Even when doing computer assisted proofs, one should not use interval arithmetics for all computations. When trying to find an approximate solution \\bar x , floating point calculations are perfectly fine, and it is only when evaluating the bounds in the Newton Kantorovich theorem that interval arithmetic must be used. \"\"\" md\"\"\" References ^1 A. Hungria, J. P. Lessard and J. D. Mireles James, Rigorous numerics for analytic solutions of differential equations the radii polynomial approach, Mathematics of Computation , 85 2016 , 1427 1459 \"\"\" "},{"url":"mod2/manifolds_equilibria/","title":"Invariant manifolds of equilibria","tags":["module2"],"text":"Jean-Philippe’s section"},{"url":"mod2/mod2/","title":"ODEs","tags":["module2"],"text":"The future has arrived!"},{"url":"mod2/periodic_orbits/","title":"Periodic orbits","tags":["module2"],"text":"Jan Bouwe’s section"},{"url":"mod2/taylor_integration/","title":"Taylor integration","tags":["module2"],"text":"Jay’s section"}]